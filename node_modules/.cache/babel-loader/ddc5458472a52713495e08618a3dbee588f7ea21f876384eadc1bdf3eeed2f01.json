{"ast":null,"code":"window.onload = () => {\n  var _window$screen;\n  const widths = [window.innerWidth];\n  if ((_window$screen = window.screen) !== null && _window$screen !== void 0 && _window$screen.width) {\n    var _window$screen2;\n    widths.push((_window$screen2 = window.screen) === null || _window$screen2 === void 0 ? void 0 : _window$screen2.width);\n  }\n  const width = Math.min(...widths);\n  if (width < 1024) {\n    document.getElementById('root').classList.add('isMobile');\n  } else {\n    document.getElementById('root').classList.remove('isMobile');\n  }\n  initObserver();\n};\nwindow.onresize = () => {\n  var _window$screen3;\n  const widths = [window.innerWidth];\n  if ((_window$screen3 = window.screen) !== null && _window$screen3 !== void 0 && _window$screen3.width) {\n    var _window$screen4;\n    widths.push((_window$screen4 = window.screen) === null || _window$screen4 === void 0 ? void 0 : _window$screen4.width);\n  }\n  const width = Math.min(...widths);\n  if (width < 1024) {\n    document.getElementById('root').classList.add('isMobile');\n  } else {\n    document.getElementById('root').classList.remove('isMobile');\n  }\n};\n// Define the callback function to execute when an element becomes visible\nfunction onIntersection(entries, observer) {\n  entries.forEach(entry => {\n    if (entry.isIntersecting) {\n      if (entry.target.classList.contains('observeElement')) entry.target.classList.add('is-visibleTitle');else if (entry.target.classList.contains('observeElement')) entry.target.classList.add('is-visibleElement');\n      observer.unobserve(entry.target);\n    }\n  });\n}\n\n// Create an instance of Intersection Observer with the callback function\nfunction createObserver() {\n  const options = {\n    root: null,\n    rootMargin: '0px',\n    threshold: 0.4 // Adjust the threshold value to control when the element is considered visible\n  };\n\n  return new IntersectionObserver(onIntersection, options);\n}\n\n// Initialize the observer and start observing elements with the class 'element-to-observe'\nexport function initObserver() {\n  const observer = createObserver();\n  const elementsToObserve = document.querySelectorAll('.observeElement , .observeElement');\n  elementsToObserve.forEach(element => {\n    observer.observe(element);\n  });\n}","map":{"version":3,"names":["window","onload","_window$screen","widths","innerWidth","screen","width","_window$screen2","push","Math","min","document","getElementById","classList","add","remove","initObserver","onresize","_window$screen3","_window$screen4","onIntersection","entries","observer","forEach","entry","isIntersecting","target","contains","unobserve","createObserver","options","root","rootMargin","threshold","IntersectionObserver","elementsToObserve","querySelectorAll","element","observe"],"sources":["C:/Users/User/SOUL Dropbox/SOUL Creative Agency/Aggelakis/SLI/sli/src/js/generic.js"],"sourcesContent":["window.onload = () => {\r\n    const widths = [window.innerWidth];\r\n\r\n    if (window.screen?.width) {\r\n      widths.push(window.screen?.width);\r\n    }\r\n\r\n    const width = Math.min(...widths);\r\n    if ( width < 1024 ) {\r\n        document.getElementById('root').classList.add('isMobile')\r\n    }\r\n    else {\r\n        document.getElementById('root').classList.remove('isMobile')\r\n    }\r\n    initObserver();\r\n}\r\nwindow.onresize = () => {\r\n    const widths = [window.innerWidth];\r\n\r\n    if (window.screen?.width) {\r\n      widths.push(window.screen?.width);\r\n    }\r\n\r\n    const width = Math.min(...widths);\r\n    if ( width < 1024 ) {\r\n        document.getElementById('root').classList.add('isMobile')\r\n    }\r\n    else {\r\n        document.getElementById('root').classList.remove('isMobile')\r\n    }\r\n}\r\n// Define the callback function to execute when an element becomes visible\r\nfunction onIntersection(entries, observer) {\r\n    entries.forEach(entry => {\r\n      if (entry.isIntersecting) {\r\n        if(entry.target.classList.contains('observeElement'))\r\n          entry.target.classList.add('is-visibleTitle');\r\n        else if (entry.target.classList.contains('observeElement'))\r\n          entry.target.classList.add('is-visibleElement');\r\n        \r\n        observer.unobserve(entry.target);\r\n      }\r\n    });\r\n  }\r\n  \r\n  // Create an instance of Intersection Observer with the callback function\r\n  function createObserver() {\r\n    const options = {\r\n      root: null,\r\n      rootMargin: '0px',\r\n      threshold: 0.4, // Adjust the threshold value to control when the element is considered visible\r\n    };\r\n  \r\n    return new IntersectionObserver(onIntersection, options);\r\n  }\r\n  \r\n  // Initialize the observer and start observing elements with the class 'element-to-observe'\r\n  export function initObserver() {\r\n    const observer = createObserver();\r\n    const elementsToObserve = document.querySelectorAll('.observeElement , .observeElement');\r\n    elementsToObserve.forEach(element => {\r\n      observer.observe(element);\r\n    });\r\n  }\r\n  "],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}